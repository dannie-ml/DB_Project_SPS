-- setup_database.sql
-- Oracle Database Setup for SPS DB Authentication System

-- Create the main users table
CREATE TABLE users (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR2(255) NOT NULL UNIQUE,
    full_name VARCHAR2(255) NOT NULL,
    hashed_password VARCHAR2(255) NOT NULL,
    is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0,1)),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP NULL
);

-- Create index on email for faster lookups
CREATE INDEX idx_users_email ON users(email);

-- Create login sessions table for token management
CREATE TABLE login_sessions (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id NUMBER NOT NULL,
    token CLOB NOT NULL,
    is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0,1)),
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_login_sessions_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create index on token for faster session validation
CREATE INDEX idx_login_sessions_token ON login_sessions(user_id, is_active);

-- Create password reset tokens table
CREATE TABLE password_reset_tokens (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id NUMBER NOT NULL,
    token VARCHAR2(255) NOT NULL,
    used NUMBER(1) DEFAULT 0 CHECK (used IN (0,1)),
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    used_at TIMESTAMP NULL,
    CONSTRAINT fk_password_reset_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create index on token for faster password reset validation
CREATE INDEX idx_password_reset_token ON password_reset_tokens(token);
CREATE INDEX idx_password_reset_user ON password_reset_tokens(user_id);

-- Create sequences (if not using IDENTITY columns)
-- These are automatically created with IDENTITY columns, but included for reference
-- CREATE SEQUENCE users_seq START WITH 1 INCREMENT BY 1 NOCACHE;
-- CREATE SEQUENCE login_sessions_seq START WITH 1 INCREMENT BY 1 NOCACHE;
-- CREATE SEQUENCE password_reset_tokens_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- Create triggers for automatic timestamp updates
CREATE OR REPLACE TRIGGER trg_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    :NEW.last_login := CURRENT_TIMESTAMP;
END;
/

-- Insert sample admin user (password: admin123)
-- Note: In production, create users through the API endpoints
INSERT INTO users (email, full_name, hashed_password, is_active, created_at) 
VALUES (
    'admin@spsdb.com', 
    'System Administrator', 
    '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqyqX3YviETJ7aWnHSWL8qy', -- hashed "admin123"
    1, 
    CURRENT_TIMESTAMP
);

-- Create view for active users (optional - for reporting)
CREATE OR REPLACE VIEW active_users AS
SELECT 
    id,
    email,
    full_name,
    created_at,
    last_login
FROM users 
WHERE is_active = 1;

-- Create view for user session statistics (optional - for monitoring)
CREATE OR REPLACE VIEW user_session_stats AS
SELECT 
    u.id,
    u.email,
    u.full_name,
    COUNT(ls.id) as total_sessions,
    COUNT(CASE WHEN ls.is_active = 1 THEN 1 END) as active_sessions,
    MAX(ls.created_at) as last_session
FROM users u
LEFT JOIN login_sessions ls ON u.id = ls.user_id
GROUP BY u.id, u.email, u.full_name;

-- Cleanup procedure for expired tokens and sessions
CREATE OR REPLACE PROCEDURE cleanup_expired_data AS
BEGIN
    -- Delete expired password reset tokens
    DELETE FROM password_reset_tokens 
    WHERE expires_at < CURRENT_TIMESTAMP;
    
    -- Deactivate expired login sessions
    UPDATE login_sessions 
    SET is_active = 0 
    WHERE expires_at < CURRENT_TIMESTAMP AND is_active = 1;
    
    -- Delete old inactive sessions (older than 30 days)
    DELETE FROM login_sessions 
    WHERE is_active = 0 
    AND created_at < CURRENT_TIMESTAMP - INTERVAL '30' DAY;
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Cleanup completed successfully');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error during cleanup: ' || SQLERRM);
        RAISE;
END cleanup_expired_data;
/

-- Schedule cleanup job (run daily at 2 AM)
-- Note: This requires appropriate privileges
/*
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'CLEANUP_EXPIRED_DATA_JOB',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN cleanup_expired_data; END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=DAILY; BYHOUR=2; BYMINUTE=0; BYSECOND=0',
        enabled         => TRUE,
        comments        => 'Daily cleanup of expired tokens and sessions'
    );
END;
/
*/

-- Grant necessary permissions (adjust schema name as needed)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON users TO your_app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON login_sessions TO your_app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON password_reset_tokens TO your_app_user;

-- Create indexes for better performance
CREATE INDEX idx_users_active ON users(is_active);
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_login_sessions_expires ON login_sessions(expires_at);
CREATE INDEX idx_password_reset_expires ON password_reset_tokens(expires_at);

COMMIT;